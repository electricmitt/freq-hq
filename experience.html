<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>FREQ. - Your Experience</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body class="experience-body">
    <div class="progress-indicator">
        <div class="progress-step completed"></div>
        <div class="progress-step completed"></div>
        <div class="progress-step active"></div>
    </div>
    
    <div class="experience-container">
        <canvas id="visual-canvas"></canvas>
        
        <div class="controls">
            <div class="mood-journey">
                <span class="current-mood">Anxious</span>
                <span class="journey-arrow">→</span>
                <span class="target-mood">Calm</span>
            </div>
            
            <div class="music-controls">
                <button class="control-button" id="play-pause">
                    <span class="play-icon">▶</span>
                </button>
                <div class="volume-control">
                    <input type="range" min="0" max="100" value="50" class="volume-slider">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Debug logging
        console.log('Script starting...');

        // Mood configurations
        const moodConfig = {
            transitions: {
                'sad': { target: 'calm', final: 'hopeful' },
                'angry': { target: 'focused', final: 'empowered' },
                'anxious': { target: 'grounded', final: 'confident' }
            },
            mappings: {
                sad: {
                    music: {
                        prompt: "slow melancholic acoustic guitar with soft piano",
                        denoising: 0.7,
                        seed: "acoustic",
                        bpm: "60-80"
                    },
                    visuals: {
                        colorPalette: [
                            0xFFB3BA, // Soft pink
                            0xBAFFC9, // Mint green
                            0xBAE1FF  // Sky blue
                        ],
                        particleSpeed: 0.01,
                        particleSize: 0.15,
                        particleCount: 200,
                        animationTempo: 0.5
                    }
                },
                calm: {
                    music: {
                        prompt: "peaceful ambient nature sounds with gentle piano",
                        denoising: 0.6,
                        seed: "ambient",
                        bpm: "70-90"
                    },
                    visuals: {
                        colorPalette: [
                            0xFFE4E1, // Misty rose
                            0xE0FFFF, // Light cyan
                            0xF0FFF0  // Honeydew
                        ],
                        particleSpeed: 0.015,
                        particleSize: 0.2,
                        particleCount: 250,
                        animationTempo: 0.7
                    }
                },
                anxious: {
                    music: {
                        prompt: "lo-fi ambient with soft pads",
                        denoising: 0.7,
                        seed: "lofi",
                        bpm: "70-90"
                    },
                    visuals: {
                        colorPalette: [
                            0xFFF0F5, // Lavender blush
                            0xF5FFFA, // Mint cream
                            0xF0F8FF  // Alice blue
                        ],
                        particleSpeed: 0.02,
                        particleSize: 0.2,
                        particleCount: 300,
                        animationTempo: 0.8
                    }
                }
            }
        };

        // Get mood states from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const currentMood = urlParams.get('current') || 'anxious';
        const targetMood = urlParams.get('target') || 'calm';
        
        console.log('Current mood:', currentMood);
        console.log('Target mood:', targetMood);
        
        // Get mood configurations
        const currentConfig = moodConfig.mappings[currentMood];
        const targetConfig = moodConfig.mappings[targetMood];
        
        console.log('Current config:', currentConfig);
        
        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#visual-canvas'),
            alpha: true,
            antialias: true
        });
        
        console.log('Renderer created:', renderer);
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        
        // Create particle system
        const particleCount = currentConfig.visuals.particleCount;
        console.log('Creating particle system with count:', particleCount);
        
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const velocities = new Float32Array(particleCount * 3);
        const initialPositions = new Float32Array(particleCount * 3);
        
        // Initialize particles
        for(let i = 0; i < particleCount; i++) {
            // Simple spherical distribution
            const radius = 10 * Math.sqrt(Math.random());
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = radius * Math.cos(phi);
            
            // Store initial positions
            initialPositions[i * 3] = positions[i * 3];
            initialPositions[i * 3 + 1] = positions[i * 3 + 1];
            initialPositions[i * 3 + 2] = positions[i * 3 + 2];
            
            // Colors with pastel effect
            const colorIndex = Math.floor(Math.random() * currentConfig.visuals.colorPalette.length);
            const color = new THREE.Color(currentConfig.visuals.colorPalette[colorIndex]);
            
            // Add slight variation to create more depth
            const brightness = 0.9 + Math.random() * 0.2; // Subtle brightness variation
            const saturation = 0.7 + Math.random() * 0.3; // Reduced saturation for pastel effect
            
            colors[i * 3] = color.r * brightness;
            colors[i * 3 + 1] = color.g * brightness;
            colors[i * 3 + 2] = color.b * brightness;
            
            // Sizes
            sizes[i] = currentConfig.visuals.particleSize * (0.5 + Math.random() * 0.5);
            
            // Velocities
            velocities[i * 3] = (Math.random() - 0.5) * currentConfig.visuals.particleSpeed;
            velocities[i * 3 + 1] = (Math.random() - 0.5) * currentConfig.visuals.particleSpeed;
            velocities[i * 3 + 2] = (Math.random() - 0.5) * currentConfig.visuals.particleSpeed;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                attribute float size;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (200.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                void main() {
                    float r = distance(gl_PointCoord, vec2(0.5));
                    if (r > 0.5) discard;
                    
                    // Enhanced glow effect for softer particles
                    float glow = 1.0 - r * 2.0;
                    glow = pow(glow, 1.2); // Reduced power for softer edges
                    
                    // Increased opacity for better visibility
                    gl_FragColor = vec4(vColor, 0.4 * glow);
                }
            `,
            transparent: true,
            vertexColors: true
        });
        
        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        
        console.log('Particle system added to scene');
        
        // Set initial camera position
        camera.position.z = 5;
        
        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.001 * currentConfig.visuals.animationTempo;
            
            // Update particle positions
            const positions = geometry.attributes.position.array;
            for(let i = 0; i < particleCount; i++) {
                positions[i * 3] += velocities[i * 3];
                positions[i * 3 + 1] += velocities[i * 3 + 1];
                positions[i * 3 + 2] += velocities[i * 3 + 2];
                
                // Add gentle wave motion
                positions[i * 3 + 1] += Math.sin(time + i * 0.1) * 0.01;
                
                // Boundary check
                const radius = Math.sqrt(
                    positions[i * 3] * positions[i * 3] +
                    positions[i * 3 + 1] * positions[i * 3 + 1] +
                    positions[i * 3 + 2] * positions[i * 3 + 2]
                );
                
                if(radius > 15) {
                    positions[i * 3] = initialPositions[i * 3] + (Math.random() - 0.5) * 2;
                    positions[i * 3 + 1] = initialPositions[i * 3 + 1] + (Math.random() - 0.5) * 2;
                    positions[i * 3 + 2] = initialPositions[i * 3 + 2] + (Math.random() - 0.5) * 2;
                }
            }
            geometry.attributes.position.needsUpdate = true;
            
            // Update shader uniforms
            material.uniforms.time.value = time;
            
            // Camera movement
            camera.position.x = Math.sin(time * 0.1) * 2;
            camera.position.y = Math.cos(time * 0.15) * 1.5;
            camera.position.z = 5 + Math.sin(time * 0.05) * 1;
            
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        // Start animation
        console.log('Starting animation...');
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Music controls
        const playPauseButton = document.getElementById('play-pause');
        const volumeSlider = document.querySelector('.volume-slider');
        let audioContext = null;
        let audioSource = null;
        let gainNode = null;
        
        // Riffusion API integration
        const API_BASE_URL = 'http://localhost:3000/api';
        
        async function generateMusic(mood) {
            console.log('Generating music for mood:', mood);
            const config = moodConfig.mappings[mood];
            console.log('Using config:', config);
            
            try {
                console.log('Sending request to generate music...');
                const response = await fetch(`${API_BASE_URL}/generate-music`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        version: "8cf61ea6c56afd61d8f5b9ffd14d7c216c0a93844ce2d82ac1c9ecc9c7f24e05",
                        input: {
                            prompt_a: config.music.prompt,
                            denoising: config.music.denoising,
                            seed_image_id: config.music.seed,
                            num_inference_steps: 50
                        }
                    })
                });
                
                const data = await response.json();
                console.log('Initial response:', data);
                
                // Poll for completion
                if (data.id) {
                    let prediction = await pollPrediction(data.id);
                    return prediction;
                }
                
                return data;
            } catch (error) {
                console.error('Error generating music:', error);
                return null;
            }
        }
        
        async function pollPrediction(id) {
            const maxAttempts = 30;
            const interval = 2000; // 2 seconds
            
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                try {
                    const response = await fetch(`${API_BASE_URL}/prediction/${id}`);
                    const data = await response.json();
                    console.log('Poll attempt', attempt + 1, ':', data.status);
                    
                    if (data.status === 'succeeded') {
                        return data;
                    } else if (data.status === 'failed') {
                        throw new Error('Music generation failed');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, interval));
                } catch (error) {
                    console.error('Error polling prediction:', error);
                    throw error;
                }
            }
            
            throw new Error('Music generation timed out');
        }
        
        async function startMusic() {
            console.log('Starting music...');
            try {
                if (!audioContext) {
                    console.log('Creating new AudioContext...');
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    gainNode = audioContext.createGain();
                    gainNode.connect(audioContext.destination);
                    
                    // Start with volume at 0
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    
                    console.log('Generating music data...');
                    const musicData = await generateMusic(currentMood);
                    console.log('Music data received:', musicData);
                    
                    if (musicData && musicData.audio) {
                        console.log('Fetching audio from URL:', musicData.audio);
                        const response = await fetch(musicData.audio);
                        const arrayBuffer = await response.arrayBuffer();
                        console.log('Audio data received, decoding...');
                        
                        audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                            console.log('Audio decoded successfully');
                            audioSource = audioContext.createBufferSource();
                            audioSource.buffer = buffer;
                            audioSource.connect(gainNode);
                            
                            // Fade in over 3 seconds
                            gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 3);
                            
                            console.log('Starting audio playback');
                            audioSource.start();
                            playPauseButton.querySelector('.play-icon').textContent = '⏸';
                        }, (error) => {
                            console.error('Error decoding audio:', error);
                        });
                    } else {
                        console.error('No audio data received from Riffusion');
                    }
                } else if (audioContext.state === 'suspended') {
                    console.log('Resuming suspended AudioContext');
                    await audioContext.resume();
                    playPauseButton.querySelector('.play-icon').textContent = '⏸';
                }
            } catch (error) {
                console.error('Error in startMusic:', error);
            }
        }
        
        // Start music automatically when page loads
        window.addEventListener('load', () => {
            console.log('Page loaded, waiting for user interaction...');
            // Wait for user interaction before starting audio
            const startAudio = async () => {
                console.log('User interaction detected, starting audio...');
                await startMusic();
                document.removeEventListener('click', startAudio);
            };
            document.addEventListener('click', startAudio);
        });
        
        playPauseButton.addEventListener('click', () => {
            console.log('Play/Pause button clicked');
            const icon = playPauseButton.querySelector('.play-icon');
            if(icon.textContent === '▶') {
                startMusic();
            } else {
                if (audioContext) {
                    console.log('Suspending audio playback');
                    audioContext.suspend();
                    icon.textContent = '▶';
                }
            }
        });
        
        volumeSlider.addEventListener('input', (e) => {
            if (gainNode) {
                const volume = e.target.value / 100;
                console.log('Setting volume to:', volume);
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            }
        });
        
        // Update mood journey display
        document.querySelector('.current-mood').textContent = currentMood;
        document.querySelector('.target-mood').textContent = targetMood;
    </script>
</body>
</html> 